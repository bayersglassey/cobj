


module [fus.heap]
docs:
    ;Implements "heap" objects which can allocate/free keys,
    ;and get/set a value for each key.

from [fus.eq]:
    eq

from [fus.bigint]:
    bigint_new
    bigint_inc

def test()():
    @heap_new
        "lol" @heap_add ='x
        "aha" @heap_add ='y
        "wtf" 'x @heap_set
        dup 'x @heap_get "wtf" == assert
        dup 'y @heap_get "aha" == assert
        dup @heap_keys {arr}(wtf aha) @eq assert
    drop


def heap_new
:
: heap
:
    obj(next_key data)
        @bigint_new =.next_key
        dict =.data

def heap_next_key
: heap
: heap key
:
    .next_key dup ='key @bigint_inc =.next_key
    'key

def heap_del
: heap key
: heap
:
    ='key .data 'key dict_del =.data

def heap_get
: heap key
: value
:
    ='key .data 'key dict_get

def heap_set
: heap value key
: heap
:
    ='key ='value
    .data 'value 'key dict_set =.data

def heap_add
: heap value
: heap key
:
    ='value @heap_next_key ='key
    .data 'value 'key dict_set =.data
    'key

def heap_keys
: heap
: keys
:
    .data keys


module [fus.bigint]
# Simple implementation of integers which can
# increase theoretically without bounds.


def char
: sym
: int
:
    # Example: [0]@char 48 == assert
    # Example: [\n]@char 10 == assert
    sym_tostr 0 str_getcode


def bigint_new
:
: bigint
: [0]

def bigint_inc
: bigint
: bigint
:
    # Increments given bigint by 1
    sym_tostr
    dup str_len 1 - ='i
    for('i 1 - ='i):
        dup 'i str_getcode [0]@char - ='digit
        'digit 9 == if:
            [0]@char 'i str_setcode
            'i 0 == if:
                "1" swap str_join break
            continue
        'digit [0]@char + 'i str_setcode break
    str_tosym
