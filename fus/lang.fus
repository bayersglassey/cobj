
# Modules can't contain other modules?
# It's more like Java where they just have big string labels.
# However, each def *does* live inside a module.
# Defs can be stored like:
#   [def]      # type
#   [map2]     # name
#   -> module
#   -> code
# Modules can be stored like:
#   [module]           # type
#   [local.geom.vec]   # name
#   :                  # refs
#     [map2] ([lib.funtools] [pairwise_map])
#   :                  # defs
#     [new] -> fun
#     [add] -> fun

# Lang parser starts off by *lexing* until it hits one
# of these tokens: module, from, def.
# There is a dict from module names to modules, and each
# module has its own obj pool.
# Each module also has a dict of defs -- and defs are just
# funs?.. Where a fun is a type of obj_t.
# Also, each module has a linked list of "scopes", which are
# the things modified by the "from" keyword.
# That is, a scope is a dict of pairs (module_name, def_name).
# Every fun has an associated module *and scope*.
# The "@" keyword does def lookup, by first checking current
# fun's scope, then checking fun's module's defs.



module [local.geom.vec]

from [lib.funtools]:
    foreach
    pairwise_map =map2

from [local.geom.trf]:
    new =[trf.new]



def new:
    args: len
    0 ='i
    nil ='v
    for('i 1 + ='i):
        'i 'len < while
        0 'v push ='v
        continue
    'v
    return: v


def add:
    args: v1 v2

    'v1 is_nil or: 'v2 is_nil
    if: nil return: v

    'v1 head 'v2 head +
    ('v1 tail 'v2 tail @add) push
    return: v


def add: fun(+) @map2

